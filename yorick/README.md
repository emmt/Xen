# A Yorick implementation of Xen

## Message channels

Yorick implementation of Xen can run a server and provide means to connect to
another server.  At most one server and one connection to a peer can exist at
the same time (for most purposes, this is not a limitation).


### Xen Server

To launch Xen server in Yorick:

```.c
xen_server, port;
```

where `port` is the port number or `0` to let the system decides.  If `port` is
omitted, `port=0` is assumed.  If successfully started, the server prints a
message indicating to which port it can be reached.  The function
`xen_get_server_port()` can be also called to query the port number where the
server is listening for connections (a value of `-1` is returned if there is no
server currently running).  After starting, the server runs in the background
and may be terminated by calling:

```.c
xen_shutdown;
```

At any time there can be at most one Xen connection used to exchange messages
with a peer.  If a Xen server is running, the first connected client will use
that connection and the connection will be denied for other clients.


### Xen Client

To connect the Yorick interpreter to another Xen server, call:

```.c
xen_connect, host, port;
```

where `host` is the address or hostname of the machine running the server (`-`
is an alias for `"localhost"`) and `port` is the port number where the server
is listening for connections.  To close the connection with the peer (if any),
call:

```.c
xen_disconnect;
```

Calling `xen_connect` raise an error if a connection already exists but
`xen_reconnect` can be called to force a reconnection:

```.c
xen_reconnect, host, port;
```

where the arguments are the same as for `xen_connect`.


### Using the Peer Connection

Once a connection to a peer is established (either by the server accepting a
connection of a client or by connecting as a client to another server), the
exchange of messages can begin.  Apart from the interpretation of the messages
which is specific to each peer, the connection is symmetric: both peers may
send messages to each other.  On Yorick side, the processing of messages
received from the peer is automatic and is done in the background (that is when
Yorick becomes idle) by a callback function.

To send a command `cmd` to be evaluated by the peer or to notify an event `evt`
to the peer, do one of:

```.c
id = xen_send_command(cmd);
id = xen_send_event(evt);
```

where the returned value `id` is the serial number to uniquely identify the
command or the event.  This number is an integer which is automatically
generated by these functions.  No answer is expected for notifying an event but
the serial number may be used to figure out whether a command was successful or
not.

To report the success or the failure of a previous command received from
the peer, the callback in charge of processing the messages is responsible of
calling one of:

```.c
xen_send_result, id, val;
xen_send_error, id, msg
```

where `id` is the serial number of the command, `val` is the result returned by
the command if successful while `msg` is the error message.  The same policy is
expected from the peer when a command is sent by Yorick with
`xen_send_command`.  The exact behavior depends on the procedure called to
respond to messages.  By default, received commands are executed and their
success or failure is reported to the peer as explained above.  Other received
messages are printed to the standard error output.


### Evaluation of Commands

When a command message is received, the text of the message is evaluated by
`xen_execute_script` in case of success, the value returned by this function is
returned (with `xen_send_result`) to the peer.  The peer has to know how this
function operates in order to craft commands that have desired side effects but
also that return useful values.

Calling:

```.c
ans = xen_execute_script(cmd);
```

compiles (with Yorick's `include` built-in function) and executes the code
specified by `cmd` (a scalar string which is specified by the command message).
In practice, the code is wrapped into an anonymous function and the returned
result `ans` is given by the first executed `return` statement in `cmd` or
nothing if there is no such statement.

For instance:

```.c
xen_execute_script("return sqrt(2);")
```

yields the value 1.41411 while:

```.c
xen_execute_script("sqrt(2);")
```

yields nothing but prints `1.41411` on Yorick's standard output because the
result of the expression is not assigned to a variable.  To avoid this, the
command should be:

```.c
xen_execute_script("dummy = sqrt(2);")
```

The code specified by `cmd` may be arbitrarily complex as far as it constitutes
valid Yorick code inside a function.  The scoping rules for the symbols used in
`cmd` are the same as for any other Yorick function.  In the above example,
`sqrt` is *extern* while `dummy` is *local*.  Statements like `local` and
`extern` may be used in `cmd` to override implicit rules.


### Message Queue

To maintain an appearence of being processed in the background, messages
received from the peer are stored in a *First In First Out* (FIFO) queue and
are processed one by one whenever Yorick becomes idle.  As a result, messages
are processed in the same order as they were received.

The management of the queue is automatically done but there are a few functions
to directly play with the message queue if needed (*e.g.*, to add new jobs).  To
query whether there are more messages, call:

```.c
xen_more_messages()
```

to push a new message at the end of the queue, call:

```.c
xen_push_message, msg;
```

and to pop the first pending message out of the queue, call:

```.c
msg = xen_pop_message();
```
